Implementation of the [sandpile model](https://en.wikipedia.org/wiki/Abelian_sandpile_model) in Rust.

Example calls:

* Identity element:\
`cargo run --release rectangle 60x50 ascii+png id out/id.png`
* [Tropical curves](https://en.wikipedia.org/wiki/Tropical_geometry) (see [Geneva Tropical Wiki / tropicalsand](https://www.unige.ch/math/tggroup/doku.php?id=tropicalsand)):\
`echo "2 6, 8 36, 12 13, 17 10." | cargo run --release rectangle 40 ascii+png add all-3 read_list out/tropical.png`
* [OEIS A256046](https://oeis.org/A256046) (see also [A256045](https://oeis.org/A256045)):\
`for ($n = 2; $n -lt 9; $n++) { cargo run --release rectangle $n order all-2 }` (PowerShell)
or\
`for n in {2..8}; do cargo run --release rectangle ${n} order all-2; done` (bash)
* [OEIS A249872](https://oeis.org/A249872) (see also [A293452](https://oeis.org/A293452)):\
`for ($n = 1; $n -lt 10; $n++) { cargo run --release torus $n topplings all-4 }`
or\
`for n in {1..9}; do cargo run --release torus ${n} topplings all-4; done`
* [OEIS A307652](https://oeis.org/A307652):\
`for ($n = 1; $n -lt 10; $n++) { cargo run --release rectangle $n chips id }`
or\
`for n in {1..9}; do cargo run --release rectangle ${n} chips id; done`
* Verify that `inverse` indeed gives inverse:\
`cargo run --release rectangle 10 eq id add inverse dup all-3`
* Drop many chips to the origin of the infinite grid:\
`cargo run --release infinite 1 png all-100000 out/1e5.png`

The executable file takes the following command line arguments (see details below):

* type of the underlying grid;
* its size;
* the sequence of commands in the normal Polish notation which operate the stack of sandpiles:
  * the first of these arguments (executed last) determines the output of the program, which may be an ascii image, a number, a boolean value (these three go to stdout as text), a png image, or some combination of these output options;
  * other commands do various jobs, and they may pop sandpiles from the stack and push sandpiles to the stack;
* if the `png` output option has been specified, the last argument is the output file name.

The underlying graph is always a rectangular grid. Various boundary conditions are available:

* `rectangle`, finite grid with sink all around the grid;
* `toroidal` grid with sink at the top-left node;
* `infinite` auto-extending grid with no sink and no sandpile group (group operations are impossible).

The default neighbourhood is the von Neumann neighbourhood (4 neighbours). To use Moore neighbourhood (8 neighbours), add `.moore` to the boundary condition, e. g., `rectangle.moore`.

The size of an `N` by `M` grid is specified as `NxM`; simply `N` means `NxN`.

The following output options are available (all but the last one expect a single sandpile in the stack, all but the last two can be combined with each other via `+`):

* `ascii`: write plaintext image of the sandpile to standard output;
* `png`: save png image of the sandpile to a file specified by the final command line argument;
* `time`: how much time did the program execution take;
* `topplings`: how many topplings did the sandpile take to stabilize during the execution of the last command;
* `chips`: total number of chips in the sandpile;
* `order`: the order of the recurrent sandpile (runs forever on a non-recurrent sandpile);
* `recurrent`: check whether the sandpile is recurrent;
* `eq`: check whether two sandpiles are equal (for infinite grids, the position of the origin is taken into account).

The following commands are available:

* `id`: find the neutral (identity) element of the sandpile group and push it to the stack;
* `read`: read a sandpile from the standard input using the same format as the `ascii` output, push;
* `read_list`: read the list of chips from stdin as pairs of coordinates: `0 0, 0 1, 0 1, 2 1.`, push;
* `all-N`: a sandpile with `N` chips in every node, push;
* `burn`: in an empty sandpile, the sink emits a chip to every neighbouring cell, push;
* `add`: pop two sandpiles from the stack, add them together, push the result;
* `inverse`: pop a sandpile from the stack, take its inverse if it is recurrent (if no, the result will still give the identity element when added to the original sandpile), push the result;
* `dup`: pop a sandpile and push it back twice.

Every time a sandpile is generated by any of these commands, it topples, so the sandpiles in the stack are always stable (but not necessarily recurrent).

The content of this repository is licensed under [Apache License 2.0](https://www.apache.org/licenses/LICENSE-2.0) or [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/) at your option.
